{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftecc\/signverify"]}],"sections":[],"abstract":[{"text":"Signing data and verifying signatures","type":"text"}],"hierarchy":{"paths":[["doc:\/\/SwiftECC\/documentation\/SwiftECC"]]},"schemaVersion":{"major":0,"patch":0,"minor":3},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/SignVerify"},"seeAlsoSections":[{"generated":true,"title":"Articles","identifiers":["doc:\/\/SwiftECC\/documentation\/SwiftECC\/KeyManagement","doc:\/\/SwiftECC\/documentation\/SwiftECC\/EncryptedKeys","doc:\/\/SwiftECC\/documentation\/SwiftECC\/EncryptDecrypt","doc:\/\/SwiftECC\/documentation\/SwiftECC\/AEADEncryptDecrypt","doc:\/\/SwiftECC\/documentation\/SwiftECC\/KeyAgrement","doc:\/\/SwiftECC\/documentation\/SwiftECC\/CreateDomain","doc:\/\/SwiftECC\/documentation\/SwiftECC\/ECArithmetic","doc:\/\/SwiftECC\/documentation\/SwiftECC\/Performance","doc:\/\/SwiftECC\/documentation\/SwiftECC\/References"]}],"metadata":{"title":"Sign and Verify","roleHeading":"Article","modules":[{"name":"SwiftECC"}],"role":"article"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"","level":2,"type":"heading","text":""},{"type":"paragraph","inlineContent":[{"text":"Signing data and verifying signatures is performed using the ECDSA algorithm. It is possible to generate","type":"text"},{"type":"text","text":" "},{"text":"deterministic signatures as specified in [RFC 6979] by setting the ","type":"text"},{"code":"deterministic","type":"codeVoice"},{"text":" parameter to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" in the sign operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The message digest used in the process is determined from the domain field size as follows:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"field size <= 224: SHA2-224"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"224 < field size <= 256: SHA2-256"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"256 < field size <= 384: SHA2-384"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"384 < field size: SHA2-512","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Example","text":"Example","level":4,"type":"heading"},{"type":"codeListing","syntax":"swift","code":["import SwiftECC","","\/\/ Get a predefined domain - for example brainpool BP160r1","","let domain = Domain.instance(curve: .BP160r1)","","\/\/ Create your own keys","","let (pubKey, privKey) = domain.makeKeyPair()","","\/\/ See how they look","","print(pubKey.asn1)","print(privKey.asn1)","","\/\/ Store them in PEM format for future use","","let pubPEM = pubKey.pem","let privPEM = privKey.pem","","let message = \"The quick brown fox jumps over the lazy dog!\".data(using: .utf8)!","","let sig = privKey.sign(msg: message)","let ok = pubKey.verify(signature: sig, msg: message)","print(\"Signature is\", ok ? \"good\" : \"wrong\")"]},{"inlineContent":[{"text":"giving (for example):","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["Sequence (2):","  Sequence (2):","    Object Identifier: 1.2.840.10045.2.1","    Object Identifier: 1.3.36.3.3.2.8.1.1.1","  Bit String (328): 00000100 00000011 00000111 00110011 01010100 00000001 10111100 01101111 10100001 01001000 11101000 01111100 10001111 00000110 00010010 11100111 11111010 10010001 00100100 01001000 11000110 01110001 00110100 01001000 10011110 01011110 11000000 10010001 01000110 01011010 01001110 01110000 00011011 01010111 10101011 01101010 00011011 01101100 01100100 01000100 01111101","","Sequence (4):","  Integer: 1","  Octet String (20): 32 96 e0 c4 d7 f5 cb 03 0c 95 63 b1 a2 c1 2f 64 4c dc d6 4c","  [0]:","    Object Identifier: 1.3.36.3.3.2.8.1.1.1","  [1]:","    Bit String (328): 00000100 00000011 00000111 00110011 01010100 00000001 10111100 01101111 10100001 01001000 11101000 01111100 10001111 00000110 00010010 11100111 11111010 10010001 00100100 01001000 11000110 01110001 00110100 01001000 10011110 01011110 11000000 10010001 01000110 01011010 01001110 01110000 00011011 01010111 10101011 01101010 00011011 01101100 01100100 01000100 01111101","","Signature is good"],"type":"codeListing"},{"text":"BlueECC Compatibility","anchor":"BlueECC-Compatibility","type":"heading","level":4},{"inlineContent":[{"text":"Signatures created by SwiftECC in the EC256r1, EC384r1 and EC521r1 domains can be verified by IBMâ€™s BlueECC product","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"using curve prime256v1, secp384r1 and secp521r1, respectively."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Likewise, signatures created by BlueECC with one of the curves"},{"text":" ","type":"text"},{"type":"text","text":"prime256v1, secp384r1 and secp521r1 can be verified by SwiftECC using domains EC256r1, EC384r1 and EC521r1, respectively."}],"type":"paragraph"},{"text":"CryptoKit Compatibility","level":4,"anchor":"CryptoKit-Compatibility","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Signatures created by SwiftECC in the EC256r1, EC384r1 and EC521r1 domains can be verified by CryptoKit","type":"text"},{"type":"text","text":" "},{"type":"text","text":"using curve P256, P384 and P521, respectively."}]},{"inlineContent":[{"text":"Likewise, signatures created by CryptoKit with one of the curves","type":"text"},{"text":" ","type":"text"},{"text":"P256, P384 and P521 can be verified by SwiftECC using domains EC256r1, EC384r1 and EC521r1, respectively.","type":"text"}],"type":"paragraph"}]}],"references":{"doc://SwiftECC/documentation/SwiftECC/CreateDomain":{"type":"topic","url":"\/documentation\/swiftecc\/createdomain","title":"Create new Domains","abstract":[{"text":"You can create your own domains as illustrated by two examples","type":"text"}],"kind":"article","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/CreateDomain","role":"article"},"doc://SwiftECC/documentation/SwiftECC/Performance":{"url":"\/documentation\/swiftecc\/performance","type":"topic","role":"article","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/Performance","abstract":[{"text":"Execution times for certain SwiftECC operations","type":"text"}],"kind":"article","title":"Performance"},"doc://SwiftECC/documentation/SwiftECC/AEADEncryptDecrypt":{"identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/AEADEncryptDecrypt","role":"article","kind":"article","title":"AEAD Encrypt and Decrypt","type":"topic","url":"\/documentation\/swiftecc\/aeadencryptdecrypt","abstract":[{"text":"Authenticated Encryption with Associated Data","type":"text"}]},"doc://SwiftECC/documentation/SwiftECC/KeyAgrement":{"type":"topic","url":"\/documentation\/swiftecc\/keyagrement","title":"Secret Key Agreement","abstract":[{"text":"Generating a shared secret","type":"text"}],"kind":"article","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/KeyAgrement","role":"article"},"doc://SwiftECC/documentation/SwiftECC/EncryptDecrypt":{"abstract":[{"text":"ECIES encryption and decryption","type":"text"}],"title":"Encrypt and Decrypt","url":"\/documentation\/swiftecc\/encryptdecrypt","role":"article","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/EncryptDecrypt","type":"topic","kind":"article"},"doc://SwiftECC/documentation/SwiftECC/EncryptedKeys":{"identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/EncryptedKeys","role":"article","kind":"article","url":"\/documentation\/swiftecc\/encryptedkeys","title":"Encrypted Private Keys","type":"topic","abstract":[{"text":"Private keys can be encrypted as described in [PKCS#5] using the PBES2 scheme","type":"text"}]},"doc://SwiftECC/documentation/SwiftECC/ECArithmetic":{"abstract":[{"text":"SwiftECC implements the common elliptic curve arithmetic operations","type":"text"}],"title":"Elliptic Curve Arithmetic","url":"\/documentation\/swiftecc\/ecarithmetic","role":"article","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/ECArithmetic","type":"topic","kind":"article"},"doc://SwiftECC/documentation/SwiftECC":{"kind":"symbol","url":"\/documentation\/swiftecc","abstract":[{"type":"text","text":"Elliptic Curve Cryptography"}],"type":"topic","identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC","role":"collection","title":"SwiftECC"},"doc://SwiftECC/documentation/SwiftECC/References":{"identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/References","role":"article","kind":"article","title":"References","type":"topic","url":"\/documentation\/swiftecc\/references","abstract":[{"text":"Algorithms from the following books and papers have been used in the implementation","type":"text"}]},"doc://SwiftECC/documentation/SwiftECC/KeyManagement":{"identifier":"doc:\/\/SwiftECC\/documentation\/SwiftECC\/KeyManagement","role":"article","kind":"article","url":"\/documentation\/swiftecc\/keymanagement","title":"Key Management","type":"topic","abstract":[{"text":"Creating new keys and loading exsisting keys","type":"text"}]}}}